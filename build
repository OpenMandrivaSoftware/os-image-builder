#!/bin/bash

set -e

listTargets() {
	find device -name config |while read r; do
		dirname $r |cut -d/ -f2-
	done
}
usage() {
	echo "Usage: $0 [ -v VERSION ] target"
	echo "	-v: Use OpenMandriva VERSION (default: cooker)"
	echo "	-K: Keep already existing build root (default: no)"
	echo "Available targets:"
	listTargets
}
run() {
	local SCRIPT="$1"
	shift
	printf '%s\n' "Running $SCRIPT"
	if [ -e $OURDIR/device/$TARGET/$SCRIPT ]; then
		. $OURDIR/device/$TARGET/$SCRIPT "$@"
	else
		local T="$TARGET"
		local DONE=false
		while [ "$T" != "." ]; do
			T="$(dirname $T)"
			if [ -e $OURDIR/device/$T/generic/$SCRIPT ]; then
				. $OURDIR/device/$T/generic/$SCRIPT "$@"
				break
			fi
		done
	fi
}
addpackageset() {
	if ! [ -e "$OURDIR/packagesets/$1.pkgs" ]; then
		echo "Unknown package set $1" >&2
		exit 1
	fi
	PACKAGESETS="$PACKAGESETS $1"
	while read p; do
		if echo $p |grep -qE '^#include '; then
			addpackageset $(echo $p |awk '{ print $2; }')
		elif ! echo $p |grep -q '^#'; then
			PACKAGES="$PACKAGES $p"
		fi
	done < <(cat "$OURDIR/packagesets/$1.pkgs")
}

if [ "$(id -u)" != "0" ]; then
	echo "Need root privileges to set ownership of extracted files."
	exec sudo $0 "$@"
	exit 1
fi

OURDIR="$(realpath $(dirname $0))"
cd "$OURDIR"

PACKAGES=""
PACKAGESETS=""
SERVICES="dbus-broker NetworkManager"
WEAKDEPS=""
addpackageset core

OMV_VERSION=cooker
while getopts "K:p:P:s:S:v:w:W" opt; do
	case $opt in
	v)
		OMV_VERSION=$OPTARG
		;;
	p)
		PACKAGES="$PACKAGES $OPTARG"
		;;
	P)
		addpackageset ${OPTARG}
		;;
	s)
		SERVICES="$SERVICES ${OPTARG}"
		;;
	S)
		SERVICES="$(echo $SERVICES |sed -e "s,^${OPTARG} ,,;s, ${OPTARG} , ,;s,^${OPTARG}\$,,;s, ${OPTARG}\$,,")"
		;;
	w)
		WEAKDEPS="--setopt=install_weak_deps=True"
		;;
	W)
		WEAKDEPS="--setopt=install_weak_deps=False"
		;;
	K)
		KEEP_OLD_ROOT=true
		;;
	*)
		echo "Unknown option $opt" >&2
		usage
		exit 1
		;;
	esac
done
shift $((OPTIND-1))

if [ -z "$1" ]; then
	usage
	exit 1
fi

TARGET="$1"
if ! [ -e device/$TARGET/config ]; then
	# Allow abbreviations, e.g. db410c instead of qualcomm/db410c
	for i in $(find device -name config); do
		if echo $i |grep -q "$TARGET/config\$"; then
			TARGET="$(dirname $i |cut -d/ -f2-)"
			break
		fi
	done
fi
if ! [ -e device/$TARGET/config ]; then
	echo "Invalid target $TARGET"
	usage
	exit 1
fi
SHORTTARGET="$(basename $TARGET)"

echo "Building OpenMandriva $OMV_VERSION image for $TARGET"
run config

# ===================================================================
# Add target specific packageset extensions (e.g. graphics drivers
# for the gui package set)
# ===================================================================
for i in $PACKAGESETS; do
	eval "XP=\${HWPACKAGES_${i}}"
	if [ -n "$XP" ]; then
		PACKAGES="$PACKAGES $XP"
	fi
done

# ===================================================================
# Prepare host system
# ===================================================================
if [ -z "$ARCH" ]; then
	echo "$TARGET doesn't specify ARCH, assuming aarch64" >&2
	ARCH=aarch64
fi

TRIPLET=$ARCH-openmandriva-linux-gnu
case $ARCH in
aarch64)
	KERNELARCH=arm64
	QEMUARCH=aarch64
	# We allow overriding KERNELTARGET in configs because
	# some bootloaders support gzipped images, some don't
	[ -z "$KERNELTARGET" ] && KERNELTARGET=Image.gz
	BOOTEFI=bootaa64.efi
	EFIARCH=arm64-efi
	;;
arm*)
	KERNELARCH=arm
	QEMUARCH=arm
	TRIPLET="${TRIPLET}eabihf"
	KERNELTARGET=zImage
	BOOTEFI=bootarm.efi
	EFIARCH=arm-efi
	;;
x86_64|znver1)
	KERNELARCH=x86
	QEMUARCH=x86_64
	KERNELTARGET=vmlinuz
	BOOTEFI=bootx64.efi
	EFIARCH=x86_64-efi
	;;
i686)
	KERNELARCH=x86
	QEMUARCH=i386
	KERNELTARGET=vmlinuz
	BOOTEFI=bootia32.efi
	EFIARCH=i386-efi
	;;
*)
	# Anything here is possibly wrong...
	KERNELARCH=$ARCH
	QEMUARCH=$ARCH
	KERNELTARGET=vmlinuz
	BOOTEFI=boot${ARCH}.efi
	EFIARCH=${ARCH}-efi
	;;
esac
if echo $ARCH |grep -qE '(64|znver1)'; then
	LIB=lib64
else
	LIB=lib
fi

NATIVEBUILD=false
[ "$ARCH" = "$(uname -m)" ] && NATIVEBUILD=true

# Expand variables in PACKAGES now that all parameters
# are known -- allowing for e.g. ${LIB}GL0 to install libGL0
# or lib64GL0 depending on target arch
PACKAGES_TMP="$PACKAGES"
PACKAGES=""
for i in $PACKAGES_TMP; do
	PACKAGES="$PACKAGES $(eval echo $i)"
done

if [ -n "$KERNEL" ]; then
	# We aren't using a packaged kernel, so we need the right toolchain...
	HOSTDEPS="$HOSTDEPS cross-$TRIPLET-gcc"
	if [ "$ARCH" = "aarch64" ]; then
		# Many aarch64 kernels (e.g. rk3399) need a 32-bit ARM compiler
		# to target a helper Cortex-M0 etc.
		HOSTDEPS="$HOSTDEPS cross-armv7hnl-openmandriva-linux-gnueabihf-gcc"
	fi
fi
$NATIVEBUILD || HOSTDEPS="$HOSTDEPS qemu-static-$QEMUARCH"
# vim-common is for xxd, used to decode EDID information for pinebookpro
HOSTDEPS="$HOSTDEPS curl make clang gcc dtc glibc-devel bison flex lib64openssl-devel hostname patch vim-common rpm-build"

if [ -n "$HOSTDEPS" ] && [ -z "$KEEP_OLD_ROOT" ]; then
	if ! dnf -y --refresh --nogpgcheck install $HOSTDEPS; then
		for i in $HOSTDEPS; do
			if ! rpm -q $i &>/dev/null; then
				echo "Couldn't install needed HOST tools. Make sure you're running current OpenMandriva"
				echo "or install $i manually"
				exit 1
			fi
		done
	fi

	# Make sure the binfmt handler knows about any qemu-static bits we may have installed...
	echo ':aarch64:M::\x7fELF\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\xb7:\xff\xff\xff\xff\xff\xff\xff\x00\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xff\xff:/usr/bin/qemu-aarch64-static:' >/proc/sys/fs/binfmt_misc/register || :
fi

# ===================================================================
# Build kernel if necessary
# ===================================================================

SMPFLAGS="-j$(getconf _NPROCESSORS_ONLN)"
[ "$SMPFLAGS" = "-j" ] && SMPFLAGS="-j8"

if [ -n "$KERNEL" ]; then
	echo "Building $TARGET kernel"
	KERNELREPO="$(echo $KERNEL |cut -d'#' -f1)"
	KERNELBRANCH="$(echo $KERNEL |cut -d'#' -f2-)"
	[ -n "$KERNELBRANCH" ] && KERNELBRANCH="-b $KERNELBRANCH"
	[ -z "$KERNEL_CONFIG" ] && KERNEL_CONFIG="defconfig"
	[ -d kernel ] || git clone --depth 1 $KERNELBRANCH $KERNELREPO kernel
	cd kernel
	[ -e scripts/lld-version.sh ] && sed -i -e "s,' ' -f 2,' ' -f 4," scripts/lld-version.sh
	PN=1
	for i in ${OURDIR}/device/${TARGET}/kernel-patches/*.patch ${OURDIR}/device/${TARGET}/kernel-patches/*.diff; do
		[ -e "$i" ] && patch -p1 -b -z .b${PN}~ <$i
		PN=$((PN+1))
	done
	for i in ${OURDIR}/device/${TARGET}/kernel-patches/*.gitpatch; do
		[ -e "$i" ] && git apply $i
	done
	run download_kernel_extras

	[ -e ${OURDIR}/device/${TARGET}/../generic/${KERNEL_CONFIG} ] && cp -f ${OURDIR}/device/${TARGET}/../generic/${KERNEL_CONFIG} arch/${KERNELARCH}/configs/
	[ -e ${OURDIR}/device/${TARGET}/${KERNEL_CONFIG} ] && cp -f ${OURDIR}/device/${TARGET}/${KERNEL_CONFIG} arch/${KERNELARCH}/configs/
	# Get rid of the "-dirty" name in localversion
	cd kernel
	git add -A || :
	git commit -am "Apply OpenMandriva patches" || :
	cd ..

	if [ "$KERNEL_GCC" = "yes" ]; then
		make $SMPFLAGS ARCH=$KERNELARCH $KERNEL_CONFIG include/config/kernel.release
	else
		make $SMPFLAGS ARCH=$KERNELARCH LLVM=1 $KERNEL_CONFIG include/config/kernel.release
	fi
	KERNELVERSION=$(cat include/config/kernel.release)
	KERNELVERSION_NUM="$(echo $KERNELVERSION |cut -d- -f1)"
	if echo $KERNELVERSION |grep -q -- -; then
		KERNELVERSION_EXTRA="$(echo $KERNELVERSION |cut -d- -f2- |sed -e 's,-,.,g')"
	fi
	cd ..

	rm -rf kernel-rpm
	mkdir kernel-rpm
	tar cf kernel-rpm/kernel.tar kernel
	zstd -22 --ultra --rm kernel-rpm/kernel.tar
	cat >kernel-rpm/kernel-$SHORTTARGET.spec <<EOF
%define debug_package %{nil}

Name:		kernel-$SHORTTARGET
Version:	$KERNELVERSION_NUM
EOF

	if [ -n "$KERNELVERSION_EXTRA" ]; then
		echo "Release:	0.$KERNELVERSION_EXTRA.1" >>kernel-rpm/kernel-$SHORTTARGET.spec
	else
		echo "Release:	1" >>kernel-rpm/kernel-$SHORTTARGET.spec
	fi
	cat >>kernel-rpm/kernel-$SHORTTARGET.spec <<EOF
Summary:	kernel for $SHORTTARGET devices
# Tarball generated from the $KERNELBRANCH branch
# of $KERNELREPO
# by os-image-builder
Source0:	kernel.tar.zst
License:	GPLv2
Provides:	kernel = %{EVRD}
Provides:	kernel-release = %{EVRD}

EOF

	cat >>kernel-rpm/kernel-$SHORTTARGET.spec <<EOF
%description
kernel for $SHORTTARGET devices

%prep
%autosetup -p1 -n kernel

%build
EOF

	# CROSS_COMPILE_ARM32 is a Sony-ism, but doesn't hurt anywhere else, so we can specify it unconditionally
	if [ "$KERNEL_GCC" = "yes" ]; then
		echo "%make_build $SMPFLAGS ARCH=$KERNELARCH CROSS_COMPILE=/usr/bin/$TRIPLET- CROSS_COMPILE_ARM32=armv7hnl-linux-gnueabihf- LD=/usr/bin/$TRIPLET-ld.bfd $KERNEL_CONFIG" >>kernel-rpm/kernel-$SHORTTARGET.spec
	else
		echo "%make_build $SMPFLAGS ARCH=$KERNELARCH CLANG_TRIPLE=$TRIPLET- CROSS_COMPILE=/usr/bin/$TRIPLET- CROSS_COMPILE_ARM32=armv7hnl-linux-gnueabihf- CC=clang LLVM=1 LD=/usr/bin/$TRIPLET-ld.bfd $KERNEL_CONFIG" >>kernel-rpm/kernel-$SHORTTARGET.spec
	fi
	if [ -n "$KERNEL_EXTRACONFIG" ]; then
		echo "scripts/config $KERNEL_EXTRACONFIG" >>kernel-rpm/kernel-$SHORTTARGET.spec
	fi
	if [ "$KERNEL_GCC" = "yes" ]; then
		echo "%make_build $KERNELTARGET dtbs modules ARCH=$KERNELARCH CROSS_COMPILE=/usr/bin/$TRIPLET- CROSS_COMPILE_ARM32=armv7hnl-linux-gnueabihf- LD=/usr/bin/$TRIPLET-ld.bfd" >>kernel-rpm/kernel-$SHORTTARGET.spec
	else
		echo "%make_build $KERNELTARGET dtbs modules ARCH=$KERNELARCH CLANG_TRIPLE=$TRIPLET- CROSS_COMPILE=/usr/bin/$TRIPLET- CROSS_COMPILE_ARM32=armv7hnl-linux-gnueabihf- CC=clang LLVM=1 LD=/usr/bin/$TRIPLET-ld.bfd" >>kernel-rpm/kernel-$SHORTTARGET.spec
	fi
	cat >>kernel-rpm/kernel-$SHORTTARGET.spec <<EOF

%install
# Install kernel modules, if any
make $SMPFLAGS INSTALL_MOD_STRIP=1 modules_install ARCH=$KERNELARCH CROSS_COMPILE=/usr/bin/$TRIPLET- INSTALL_MOD_PATH=%{buildroot} INSTALL_DTBS_PATH=%{buildroot}/boot CROSS_COMPILE_ARM32=armv7hnl-linux-gnueabihf-
# And DTBs -- allow failure here because old kernels (onyx08 and friends)
# don't have the dtbs_install target
make $SMPFLAGS INSTALL_MOD_STRIP=1 dtbs_install ARCH=$KERNELARCH CROSS_COMPILE=/usr/bin/$TRIPLET- INSTALL_MOD_PATH=%{buildroot} INSTALL_DTBS_PATH=%{buildroot}/boot CROSS_COMPILE_ARM32=armv7hnl-linux-gnueabihf- || :
cp arch/$KERNELARCH/boot/$KERNELTARGET %{buildroot}/boot/vmlinuz-$KERNELVERSION

%files
/boot/*
/lib/modules/*
EOF
	cd kernel-rpm
	rpmbuild -bb --target $ARCH --define "_sourcedir $(pwd)" --define "_specdir $(pwd)" --define "_srcrpmdir $(pwd)/SRPMS" --define "_rpmdir $(pwd)/RPMS"  kernel-$SHORTTARGET.spec
	cd ..
	KERNELRPM="$(ls $OURDIR/kernel-rpm/RPMS/*/*.rpm)"
else
	echo "KERNEL not specified in $TARGET config - assuming packaged kernel"
fi

# ===================================================================
# Generate root filesystem
# ===================================================================

# First of all let's find the right repo list...

ROOTDIR=OpenMandriva-$OMV_VERSION-$ARCH-root

if [ -z "$KEEP_OLD_ROOT" ]; then
	# Before removing make sure bind mounts are unmounted
	for mp in /proc /sys /dev/pts /dev; do
	    echo "Checking for $ROOTDIR$mp"
	    [ -e "$ROOTDIR$mp" ] && umount -Rq "$ROOTDIR$mp" ||:
	done
	rm -rf "$ROOTDIR"
fi

if [ ! -d "$ROOTDIR" ]; then
	mkdir -p $ROOTDIR

	# setup-rootfs can do things like create a filesystem and
	# loopback mount it on $ROOTDIR -- useful for boards that
	# need to generate a FS image file rather than a rootfs
	# tarball or so.
	[ -e $OURDIR/device/$TARGET/setup-rootfs ] && . $OURDIR/device/$TARGET/setup-rootfs

	# Poor man's version of "dnf install --installroot=" --
	# need to get the repository configs from rpm packages
	# without having the repositories configured...
	PKGS=http://abf-downloads.openmandriva.org/$OMV_VERSION/repository/$ARCH/main/release/
	echo $PKGS
	curl -s -L $PKGS |grep '^<a' |cut -d'"' -f2 >PACKAGES
	PRE_PACKAGES="distro-release-repos"
	for i in $PRE_PACKAGES; do
		P=$(grep "^$i-[0-9].*" PACKAGES |tail -n1)
		if [ "$?" != "0" ]; then
			echo "Can't find $i package for target" >&2
			exit 1
		fi
		curl -O $PKGS/$P
		rpm -r $OURDIR/$ROOTDIR -Uvh --ignorearch --nodeps $P
	done

	# Don't use mirrors when creating the image
	sed -i -e '/mirror.openmandriva.org/d;s,^	,baseurl=,' "$OURDIR/$ROOTDIR"/etc/yum.repos.d/*.repo

	if ! $NATIVEBUILD; then
		# Make sure we can run %post scripts in the chroot
		mkdir -p $OURDIR/$ROOTDIR/usr/bin
		cp /usr/bin/qemu-$QEMUARCH-static $OURDIR/$ROOTDIR/usr/bin/
	fi

	# FIXME workaround for ldd being broken on aarch64 (at least in qemu)
	# (causes dracut to miss bash's dependencies)
	if [ "$ARCH" = "aarch64" ]; then
		PACKAGES="$PACKAGES xldd"
	fi
	if [ "$NEED_INITRD" != "no" ]; then
		PACKAGES="$PACKAGES dracut"
	fi
	if [ "$USE_UEFI" = "yes" ]; then
		PACKAGES="$PACKAGES efibootmgr grub2-efi"
	fi
	if [ "$USE_SYSTEMD_UEFI" = "yes" ]; then
		PACKAGES="$PACKAGES efibootmgr systemd-boot"
	fi

	PACKAGES="$PACKAGES $HWPACKAGES"

	# Mount relevant filesystems so %post scripts can access
	# the likes of /dev/null and /dev/urandom
	for mp in /proc /sys /dev/pts /dev; do
		mkdir -p "$OURDIR/$ROOTDIR$mp" || :
		mount --bind $mp "$OURDIR/$ROOTDIR$mp"
	done

	if [ -z $KEEP_OLD_ROOT ]; then
	    if ! dnf -y install --nogpgcheck --installroot=$OURDIR/$ROOTDIR --releasever=$OMV_VERSION --forcearch=$ARCH $WEAKDEPS $PACKAGES $KERNELRPM; then
		    if [ -e $OURDIR/$ROOTDIR/bin/sh ]; then
			cat >&2 <<EOF
WARNING: dnf returned an error code, but it looks like installation finished.
This is likely something (relatively) harmless like a package's post-install
script failing - but you may want to double-check.
EOF
		    else
			echo "ERROR: dnf failed without installing what looks like a workable system."
			exit 1
		    fi
	    fi
	fi

	# FIXME (continued) workaround for ldd being
	# broken on aarch64 (at least in qemu)
	# (causes dracut to miss bash's dependencies)
	if [ "$ARCH" = "aarch64" ]; then
		mv $OURDIR/$ROOTDIR/usr/bin/ldd $OURDIR/$ROOTDIR/usr/bin/ldd.glibc
		ln -sf xldd $OURDIR/$ROOTDIR/usr/bin/ldd
	fi

	if ! grep -q '^omv:' $OURDIR/$ROOTDIR/etc/passwd; then
		# Create omv user (password omv)
		echo 'omv:x:1001:1001::/home/omv:/bin/bash' >>$OURDIR/$ROOTDIR/etc/passwd
		echo 'omv:$6$rG3bQ92hkTNubV1p$5qPB9FoXBhNcSE1FOklCoEDowveAgjSf2cHYVwCENZaWtgpFQaRRRN5Ihwd8nuaKMdA1R1XouOasJ7u5dbiGt0:17302:0:99999:7:::' >>$OURDIR/$ROOTDIR/etc/shadow
		echo 'omv:x:1001:' >>$OURDIR/$ROOTDIR/etc/group
		# Add the omv user to important groups...
		for group in audio dialout input lp lpadmin network render sambashare screen storage tty users video wheel; do
			sed -i -e "s,$group:.*\$,&omv," $OURDIR/$ROOTDIR/etc/group
		done
		cp -a $OURDIR/$ROOTDIR/etc/skel $OURDIR/$ROOTDIR/home/omv
		chown -R 1001:1001 $OURDIR/$ROOTDIR/home/omv
		# Set some reasonable defaults...
		cat >$OURDIR/$ROOTDIR/etc/locale.conf <<'EOF'
LANG=en_US.utf8
LC_ADDRESS=en_US.utf8
LC_IDENTIFICATION=en_US.utf8
LC_MEASUREMENT=en_US.utf8
LC_MONETARY=en_US.utf8
LC_NAME=en_US.utf8
LC_NUMERIC=en_US.utf8
LC_PAPER=en_US.utf8
LC_TELEPHONE=en_US.utf8
LC_TIME=en_US.utf8
EOF
		cat >$OURDIR/$ROOTDIR/etc/vconsole.conf <<'EOF'
KEYMAP=us
FONT=latarcyrheb-sun16
EOF

		# Unlock root account (also password omv)
		sed -i -e 's,^root:.:,root:$6$rG3bQ92hkTNubV1p$5qPB9FoXBhNcSE1FOklCoEDowveAgjSf2cHYVwCENZaWtgpFQaRRRN5Ihwd8nuaKMdA1R1XouOasJ7u5dbiGt0:,' $OURDIR/$ROOTDIR/etc/shadow

		# If sddm is installed, set it up to autologin as omv
		if [ -z "$SDDMSESSION" ]; then
			for desktop in plasma lxqt openbox failsafe; do
				if [ -e $OURDIR/$ROOTDIR/usr/share/xsessions/$desktop.desktop ]; then
					SDDMSESSION=$desktop
					break
				fi
			done
			if [ -z "$SDDMSESSION" ]; then
				for desktop in plasma-mobile plasmawayland weston; do
					if [ -e "$OURDIR/$ROOTDIR"/usr/share/wayland-sessions/$desktop.desktop ]; then
						SDDMSESSION=$desktop
						break
					fi
				done
			fi
		fi
		if [ -z "$NO_AUTOLOGIN" ] && [ -n "$SDDMSESSION" ] && [ -e $OURDIR/$ROOTDIR/etc/sddm.conf ]; then
			sed -i -e "s,^User=,User=omv,;s,^Session=,Session=$SDDMSESSION," $OURDIR/$ROOTDIR/etc/sddm.conf
		fi
	fi
	if [ -z "$KERNEL" ]; then
		# Using packaged kernel -- let's determine KERNELVERSION
		# nevertheless so we can run dracut and possibly configure
		# bootloaders
		KERNELVERSION=$(ls --sort=time $OURDIR/$ROOTDIR/boot/vmlinuz-* 2>/dev/null|head -n1 |sed -e 's,.*vmlinuz-,,')
	fi
	# Handle post-processing scripts needed by packagesets
	for i in $PACKAGESETS; do
		[ -e "$OURDIR/packagesets/$1.post" ] && chroot "$OURDIR/$ROOTDIR" "$OURDIR/packagesets/$1.post"
	done

	run setup-system-files
	if [ "$NEED_INITRD" != "no" ] || [ "$USE_UEFI" = "yes" ] || [ "$USE_SYSTEMD_UEFI" != "yes" ] && [ -n "$KERNELVERSION" ]; then
		if [ "$NEED_INITRD" != "no" ]; then
			run generate-initrd
		fi
		if [ "$USE_UEFI" = "yes" ]; then
			printf '%s\n' "Creating ESP for GRUB."
			mkdir -p $OURDIR/$ROOTDIR/boot/efi/EFI/BOOT
			chroot "$OURDIR/$ROOTDIR" /usr/bin/grub2-mkimage -o /boot/efi/EFI/BOOT/$BOOTEFI -O $EFIARCH -p /EFI/BOOT fat part_gpt part_msdos normal boot linux configfile loopback chain efifwsetup efi_gop ls search search_label search_fs_uuid search_fs_file gfxterm gfxterm_background gfxterm_menu test all_video loadenv exfat ext2
		fi

		if [ "$USE_SYSTEMD_UEFI" = "yes" ]; then
			printf '%s\n' "Creating ESP for systemd-boot."
			mkdir -p $OURDIR/$ROOTDIR/efi
			# create ESP directory scheme for systemd-boot
			for i in "$OURDIR/$ROOTDIR/efi/EFI/BOOT" "$OURDIR/$ROOTDIR/efi/EFI/Linux" "$OURDIR/$ROOTDIR/efi/EFI/systemd" "$OURDIR/$ROOTDIR/efi/loader/entries"; do
			    mkdir -p $i
			done

			if [ ! -s "$OURDIR/$ROOTDIR"/usr/lib/kernel/cmdline ]; then
			    for i in ${CMDLINE[@]}; do
				printf '%s\n' "$i" >> "$OURDIR/$ROOTDIR"/usr/lib/kernel/cmdline
			    done
			fi

#			chroot "$OURDIR/$ROOTDIR" SYSTEMD_RELAX_ESP_CHECKS=1 bootctl install --esp-path=/efi
			cp -a "$OURDIR/$ROOTDIR"/usr/lib/systemd/boot/efi/systemd-bootaa64.efi $OURDIR/$ROOTDIR/efi/EFI/BOOT/BOOTAA64.efi
			cp -a "$OURDIR/$ROOTDIR"/usr/lib/systemd/boot/efi/systemd-bootaa64.efi $OURDIR/$ROOTDIR/efi/EFI/systemd
			KVER="$(ls --sort=time "$OURDIR/$ROOTDIR"/boot/vmlinuz-* 2>/dev/null|head -n1 |sed -e 's,.*vmlinuz-,,')"
			MACH_ID=$(chroot $OURDIR/$ROOTDIR systemd-machine-id-setup --print)
			mkdir -p "$OURDIR/$ROOTDIR/efi/$MACH_ID"
			chroot "$OURDIR/$ROOTDIR" kernel-install -v add "$KVER" "/boot/vmlinuz-$KVER"
# tricky part, looks like uboot does not support gziped kernel image in UEFI mode
# so lets gunzip it
			mv "$OURDIR/$ROOTDIR/efi/$MACH_ID/$KVER"/linux "$OURDIR/$ROOTDIR/efi/$MACH_ID/$KVER"/linux.gz
			gunzip "$OURDIR/$ROOTDIR/efi/$MACH_ID/$KVER"/linux.gz
			cat >$OURDIR/$ROOTDIR/efi/loader/loader.conf<<EOF
default $MACH_ID-$KVER.conf
timeout 10
EOF
			sed -i -e 's,efi\/,\/,g' "$OURDIR/$ROOTDIR"/efi/loader/entries/$MACH_ID-$KVER.conf
			if [ -n ${DTB} ] && ! grep -q devicetree $OURDIR/$ROOTDIR/efi/loader/entries/$MACH_ID/$KVER.conf; then
			    install -D -m644 "$OURDIR/$ROOTDIR/boot/dtb-$KVER/${DTB}.dtb" "$OURDIR/$ROOTDIR/efi/$MACH_ID/$KVER/dtb/${DTB}.dtb"
			    install -D -m644 "$OURDIR/$ROOTDIR/boot/dtb-$KVER/${DTB}.dtb" "$OURDIR/$ROOTDIR/efi/dtb/${DTB}.dtb"
			    printf '%s\n' "devicetree "/$MACH_ID/$KVER"/dtb/$DTB.dtb" >> $OURDIR/$ROOTDIR/efi/loader/entries/$MACH_ID-$KVER.conf
			fi
			dd if=/dev/random of="$OURDIR/$ROOTDIR/efi/loader/"random-seed bs=512 count=1
			chmod +x -R $OURDIR/$ROOTDIR/efi
		fi

	fi

	# Initialize the random seed to something, systemd might hang forever on
	# e.g. an embedded board that doesn't get entropy
	dd if=/dev/random of="$OURDIR/$ROOTDIR"/var/lib/systemd/random-seed bs=512 count=1
	chmod 0600 "$OURDIR/$ROOTDIR"/var/lib/systemd/random-seed

	# Make sure default services are started
	for i in "$OURDIR/$ROOTDIR"/lib/systemd/system-preset/*.preset; do
		while read r; do
			TYPE="$(echo $r |awk '{ print $1; }')"
			if [ "$TYPE" = "enable" ] || [ "$TYPE" = "disable" ]; then
				[ "$(echo "$r" |awk '{ print $2; }')" = '*' ] && continue
				chroot "$OURDIR/$ROOTDIR" /usr/bin/systemctl $r || :
			fi
		done < $i
	done

	# Some devices require special alsa configs to initialize
	# (e.g. unmuted DAC).
	# Since /var/lib/alsa/asound.state is restored (and stored) by
	# our systemd files, it's better to just initialize that (and
	# not overwrite newly saved states by a package update) than to
	# ship the file in a package.
	if [ -e "$OURDIR"/device/$TARGET/asound.state ]; then
		mkdir -p "$OURDIR/$ROOTDIR"/var/lib/alsa
		install -c -m 644 "$OURDIR"/device/$TARGET/asound.state "$OURDIR/$ROOTDIR"/var/lib/alsa/asound.state
	fi

	# Make sure key services are started even if they're omitted
	# in the preset files
	chroot "$OURDIR/$ROOTDIR" /usr/bin/systemctl enable getty@tty1.service
	[ -e "$OURDIR/$ROOTDIR"/lib/systemd/system/simplelogin.service ] && chroot "$OURDIR/$ROOTDIR" /usr/bin/systemctl enable simplelogin
	[ -e "$OURDIR/$ROOTDIR"/lib/systemd/system/sddm.service ] && chroot "$OURDIR/$ROOTDIR" /usr/bin/systemctl enable sddm
	if [ -e "$OURDIR/$ROOTDIR/lib/systemd/system/sddm.service" ] || [ -e "$OURDIR/$ROOTDIR/lib/systemd/system/simplelogin.service" ]; then
		chroot "$OURDIR/$ROOTDIR" /usr/bin/systemctl set-default graphical.target
	else
		chroot "$OURDIR/$ROOTDIR" /usr/bin/systemctl set-default multi-user.target
	fi
	# At least while we're mostly dealing with headless boards
	[ -e "$OURDIR/$ROOTDIR/lib/systemd/system/sshd.service" ] && chroot "$OURDIR/$ROOTDIR" /usr/bin/systemctl enable sshd
	for i in $SERVICES; do
		if [ -e "$OURDIR/$ROOTDIR/lib/systemd/system/$i.service" ]; then
			chroot "$OURDIR/$ROOTDIR" /usr/bin/systemctl enable $i
		else
			echo "WARNING: Service $i requested, but not installed" >&2
		fi
	done
	pushd $OURDIR/$ROOTDIR
	run postprocess
	# Before removing make sure bind mounts are unmounted
	for mp in /proc /sys /dev/pts /dev; do
	    echo 'Try umount "$OURDIR/$ROOTDIR$mp"'
	    [ -e "$OURDIR/$ROOTDIR$mp" ] && umount -Rq "$OURDIR/$ROOTDIR$mp" || :
	done
	# There shouldn't be any files in the root filesystem. If there are any,
	# they're probably core dump files generated by qemu while running systemctl
	# and friends.
	for i in *; do
		[ -f "$i" ] && rm -f "$i"
	done
	popd
else
	# Mount relevant filesystems so generate-bootimg can use
	# the likes of /dev/null and /dev/urandom in chroot
	for mp in /proc /sys /dev /dev/pts; do
		mkdir -p "$OURDIR/$ROOTDIR$mp" || :
		mount --bind $mp "$OURDIR/$ROOTDIR$mp"
	done
fi

# Reinstall distro-release-repos to get mirrors back

[ -z $KEEP_OLD_ROOT ] && dnf -y reinstall --installroot="$OURDIR/$ROOTDIR" --releasever=$OMV_VERSION --forcearch=$ARCH distro-release-repos
[ -d "$OURDIR/$ROOTDIR/var/cache/dnf" ] && rm -rf "$OURDIR/$ROOTDIR/var/cache/dnf/*"

run generate-bootimg
# Stuff in virtual filesystems should not make it to
# root filesystems...
for mp in /proc /sys /dev/pts /dev; do
    [ -e "$OURDIR/$ROOTDIR$mp" ] && umount -Rq "$OURDIR/$ROOTDIR$mp" || :
done
run generate-rootfs

if [ "$ABF" = "1" ]; then
	# ABF will package anything left in $OURDIR -- so let's
	# get rid of everything we don't want to ship and pull
	# in the README file
	[ -e device/${TARGET}/README.md ] && mv device/${TARGET}/README.md .
	cd "$OURDIR"
	rm -rf "$ROOTDIR" kernel device LICENSE PACKAGES *.rpm
	rm -f build
fi
